## 什么是跨域？

由于浏览器的同源策略，不同源之间的数据交互是被限制的，而跨域是指一个域下的文档或脚本想要去请求另一个域下的资源。

## 什么是同源策略？

> 同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![](https://cloud-images-1255423800.cos.ap-guangzhou.myqcloud.com/js_%E8%B7%A8%E5%9F%9F-1.png)

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点（DOM 元素也有同源策略）
- AJAX 请求发送后，结果被浏览器拦截了（**请求发送出去了，也拿到结果了，只是被浏览器截胡了**）

以下三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

## 为什么浏览器会禁止跨域？

**简答**：

首先，跨域只存在于浏览器端，因为我们知道浏览器的形态是很开放的，所以我们需要对它有所限制。

其次，同源策略主要是为了保证用户信息的安全，可分为两种：`Ajax`同源策略和`DOM`同源策略。

`Ajax`同源策略主要是使得不同源的页面不能获取`cookie`且不能发起`Ajax`请求，这样在一定层度上防止了`CSRF`攻击。

`DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`，这样可以防止一些恶意网站在自己的网站中利用`iframe`嵌入正gui的网站并迷惑用户，以此来达到窃取用户信息。

**深答**：

- 首先，跨域只存在于浏览器端。浏览器它为`web`提供了访问入口，并且访问的方式很简单，在地址栏输入要访问的地址或者点击某个链接就可以了，正是这种**开放的形态**，所以我们需要对它有所限制。

- 所以同源策略它的产生主要是为了保证用户信息的安全，防止恶意的网站窃取数据。分为两种：`Ajax`同源策略与`DOM`同源策略：

  - `Ajax`同源策略它主要做了这两种限制：1.不同源页面不能获取`cookie`；2.不同源页面不能发起`Ajax`请求。我认为它是防止`CSRF`攻击的一种方式吧。因为我们知道`cookie`这个东西它主要是为了解决浏览器与服务器会话状态的问题，它本质上是存储在浏览器或本地文件中一个小小的文本文件，那么它里面一般都会存储了用户的一些信息，包括隐私信息。如果没有`Ajax`同源策略，恶意网站只需要一段脚本就可以获取你的`cookie`，从而冒充你的身份去给其它网站发送恶意的请求。
  - `DOM`同源策略也一样，它限制了不同源页面不能获取`DOM`。例如一个假的网站利用`iframe`嵌套了一个银行网站[mybank.com]()，并把宽高或者其它部分调整的和原银行网站一样，仅仅只是地址栏上的域名不同，若是用户没有注意的话就以为这个是个真的网站。如果这时候用户在里面输入了账号密码，如果没有同源策略，那么这个恶意网站就可以获取到银行网站中的`DOM`，也就能拿到用户的输入内容以此来达到窃取用户信息的攻击。

  同源策略它算是浏览器安全的第一层屏障吧，因为就像`CSRF`攻击，它只能限制不同源页面`cookie`的获取，但是攻击者还可能通过其它的方式来达到攻击效果。

（注，上面提到的`iframe`限制`DOM`查询，案例如下）

```js
// HTML
<iframe name="yinhang" src="www.yinhang.com"></iframe>
// JS
// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom
const iframe = window.frames['yinhang']
const node = iframe.document.getElementById('你输入账号密码的Input')
console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)
```

## 解决方案

### 1、JSONP

```js
// koa
router.get('/getName', async (ctx) => {
  	let { callback } = ctx.request.query
  	ctx.body = `${callback}("Leon")`
})

// js
function jsonp({ url, params, callback }) {
    return new Promise((resolve) => {
        let arr = []
        params = { ...params, callback }
        for (let key in params) {
            arr.push(`${key}=${params[key]}`)
        }
        window[callback] = function(res) {
            resolve(res)
            document.body.removeChild(script)
            delete window[callback]
        }
        let script = document.createElement('script')
        script.src = `${url}?${arr.join('&')}`
        document.body.append(script)
    })
}

this.jsonp({
    url: 'http://localhost:3000/getName',
    callback: 'cb',
}).then((res) => {
    console.log('res', res) // Leon
})
```

### 2、CORS

