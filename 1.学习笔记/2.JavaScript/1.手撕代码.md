## 1、手撕 call

思路:  
1. 将函数设为对象的属性
2. 执行该函数
3. 删除该函数

### es6

```js
Function.prototype.call = function(context, ...args) {
    context = context || window
    let fn = Symbol('fn')
    context[fn] = this
    let result = context[fn](...args)
    delete context[fn]
    return result
}
```

### es5

```js
Function.prototype.call = function(context) {
    context = context || window
    context.__fn__ = this
    var args = []
    for (var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']')
    }
    var result = eval('context.__fn__(' + args + ')')
    delete context.__fn__
    return result
}
```

## 2、手撕 apply

### es6

```js
Fcuntion.prototype.apply = function(context, arr) {
    context = context || window
    let fn = Symbol('fn')
    context[fn] = this
    let result = context[fn](...arr)
    delete context[fn]
    return result
}
```

### es5

```js
Function.prototype.apply = function(context, arr) {
    context = context || window
    context.__fn__ = this
    var result
    if (!arr) {
        result = context.__fn__()    
    } else {
        var args = []
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']')
        }
        result = eval('context.__fn__(' + args + ')')
    }
    delete context.__fn__
    return result
}
```

## 3、手撕 bind

```js
Function.prototype.bind = function(context) {
    var self = this
    var args = [].slice.call(arguments, 1)

    var fBound = function() {
        var bindArgs = [].slice.call(arguments)
        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs))
    }
    fBound.prototype = Object.create(this.prototype)
    return fBound
}
```

## 4、手撕 new 

```js
function objectFactory() {
    var constructor = [].shift.call(arguments)
    var obj = Object.create(constructor.prototype)
    var result = constructor.apply(obj, arguments)
    return typeof result === 'object' ? result || obj : obj
}
```

## 5、防抖函数

```js
function debounce(func, wait, immediate) {
    var timeout, result
    return function() {
        var context = this
        var args = arguments
        if (timeout) clearTimeout(timeout)
        if (immediate) {
            if (!timeout) {
                result = func.apply(context, args)
            }
            timeout = setTimeout(() => {
                timeout = null
            }, wait)
        } else {
            timeout = setTimeout(() => {
                func.apply(context, args)
            }, wait)
        }
        return result
    }
}
```

## 6、节流函数

```js
function throttle(func, wait) {
    var previous = 0
    return function() {
        var context = this
        var args = arguments
        var now = Date.now()
        if (now - previous > wait) {
            func.apply(context, args)
            previous = now
        }
    }
}

function throttle(func, wait) {
    var timeout
    return function() {
        var context = this
        var args = arguments
        if (!timeout) {
            timeout = setTimeout(() => {
                func.apply(context, args)
                timeout = null
            }, wait)
        }
    }
}
```

## 7、jsonp 解决跨域

```js
// koa
router.get('/getName', async (ctx) => {
  	let { callback } = ctx.request.query
  	ctx.body = `${callback}("Leon")`
})

// js
function jsonp({ url, params, callback }) {
    return new Promise((resolve) => {
        let arr = []
        params = { ...params, callback }
        for (let key in params) {
            arr.push(`${key}=${params[key]}`)
        }
        window[callback] = function(res) {
            resolve(res)
            document.body.removeChild(script)
            delete window[callback]
        }
        let script = document.createElement('script')
        script.src = `${url}?${arr.join('&')}`
        document.body.appendChild(script)
    })
}

this.jsonp({
    url: 'http://localhost:3000/getName',
    callback: 'cb',
}).then((res) => {
    console.log('res', res) // Leon
})
```

## 8、原生 js 实现 ajax

1. 创建一个 XMLHttpRequest 异步对象

2. 设置请求方式和请求地址

3. 接着，用send发送请求

4. 监听状态变化

5. 最后，接收返回的数据

```js
function ajax(options) {
        options = options || {}
        options.type = (options.type || 'GET').toUpperCase()
        options.dataType = options.dataType || 'json'

        var params = ((data) => {
            var arr = [];
            for(var name in data){
                arr.push(`${encodeURIComponent(name)}=${encodeURIComponent(data[name])}`)
            }
            arr.push(`${v}=${Math.random()}`)
            return arr.join('&')
        })(options.data)

        var xhr
        // 考虑兼容性
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest()
        } else if (window.ActiveXObject) {
            // 兼容IE6以下版本
            xhr = new ActiveXObject('Microsoft.XMLHTTP')
        }

        // 启动并发送一个请求
        if (options.type == 'GET') {
            xhr.open('GET', `${options.url}?${params}`, true)
            xhr.send(null)
        } else if (options.type == 'POST') {
            xhr.open('post', options.url, true)

            // 设置表单提交时的内容类型
            // Content-type 数据请求的格式
            xhr.setRequestHeader('Content-type', options['Content-type'] || 'application/x-www-form-urlencoded')
            xhr.send(params)
        }

        // 设置有效时间
        setTimeout(function() {
            if (xhr.readyState != 4) {
                xhr.abort()
            }
        }, options.timeout)

        // 接收
        // options.success 成功之后的回调函数，options.error 失败后的回调函数
        // xhr.responseText，xhr.responseXML，获得字符串形式的响应数据或者 XML 形式的响应数据
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                var status = xhr.status
                if ((status >= 200 && status < 300) || status == 304) {
                    options.success && options.success(xhr.responseText, xhr.responseXML)
                } else {
                    options.error && options.error(status)
                }
            }
        }
    }
```

## 9、ES5 实现 Object.is()

S5中的`==`和`===`存在着问题，`==`会自动转换数据类型；`===`情况下NaN不等于NaN，+0等于-0

```js
NaN === NaN     // false
+0 === -0       // true
```

ES6中的`Object.is()` 判断两个值是否相同。即只要两个值是一样的，它们就应该相等。

```js
Object.is(NaN, NaN)     // true
Object.is(+0, -0)       // false
```

如果下列任何一项成立，则两个值相同：

- 两个值都是 undefined
- 两个值都是 null
- 两个值都是 true 或者都是 false
- 两个值是由相同个数的字符按照相同的顺序组成的字符串
- 两个值指向同一个对象
- 两个值都是数字并且
- 都是正零 +0
  都是负零 -0
  都是 NaN
  都是除零和 NaN 外的其它同一个数字

```js
Object.is = function(x, y) {
    if (x === y) {
        // 当前情况下，只有一种情况是特殊的，即 +0 -0
        // 如果 x !== 0，则返回true
        // 如果 x === 0，则需要判断+0和-0，则可以直接使用 1/+0 === Infinity 和 1/-0 === -Infinity来进行判断
        return x !== 0 || 1 / x === 1 / y;
    }
    
    // x !== y 的情况下，只需要判断是否为NaN，如果x!==x，则说明x是NaN，同理y也一样
    // x和y同时为NaN时，返回true
    return x !== x && y !== y;
}
```

## 10、splice

```js
/**
 * @param {number} idx 开始删除的索引
 * @param {number} deleteCount 需要删除的数目
 * @param {any[]} insertItems 需要插入项
 * @returns {any[]} 被删的数组项的数组
 */
Array.prototype._splice = function(start, deleteCount, ...addList) {
    if (start < 0) {
        if (Math.asb(start) > this.length) {
            start = 0
        } else {
            start += this.length
        }
    }

    if (typeof deleteCount === 'undefined') {
        deleteCount = this.length - start
    }

    let removeList = this.slice(start, start + deleteCount)
    let right = this.slice(start + deleteCount)

    let addIndex = start
    addList.concat(right).forEach(item => {
        this[addIndex] = item
        addIndex++
    })
    this.length = addIndex

    return removeList
}
```

## 11、浅拷贝与深拷贝

### 浅拷贝

1. `Object.assign()`

   ```js
   let a = {
       name: "muyiy",
       book: {
           title: "You Don't Know JS",
           price: "45"
       }
   }
   let b = Object.assign({}, a);
   console.log(b);
   // {
   // 	name: "muyiy",
   // 	book: {title: "You Don't Know JS", price: "45"}
   // } 
   
   a.name = "change";
   a.book.price = "55";
   console.log(a);
   // {
   // 	name: "change",
   // 	book: {title: "You Don't Know JS", price: "55"}
   // } 
   
   console.log(b);
   // {
   // 	name: "muyiy",
   // 	book: {title: "You Don't Know JS", price: "55"}
   // } 
   ```

2. 展开语法 `Spred`

   ```js
   let a = {
       name: "muyiy",
       book: {
           title: "You Don't Know JS",
           price: "45"
       }
   }
   let b = {...a};
   console.log(b);
   // {
   // 	name: "muyiy",
   // 	book: {title: "You Don't Know JS", price: "45"}
   // } 
   
   a.name = "change";
   a.book.price = "55";
   console.log(a);
   // {
   // 	name: "change",
   // 	book: {title: "You Don't Know JS", price: "55"}
   // } 
   
   console.log(b);
   // {
   // 	name: "muyiy",
   // 	book: {title: "You Don't Know JS", price: "55"}
   // } 
   ```

3. 数组 `Array.prototype.slice()`

4. 数组 `Array.prototype.concat()`

### 深拷贝

- 简易版（深度优先遍历，未考虑循环引用等等）

  ```js
  function checkType(val) {
      return Object.prototype.toString.call(val).slice(8, -1)
  }
  
  function deepClone(obj) {
      if (typeof obj !== 'object') {
          return obj
      }
      let ret = checkType(obj) === 'Object' ? {} : []
      for (let i in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, i)) {
              if (checkType(obj[i]) === 'Object' || checkType(obj[i]) === 'Array') {
                  ret[i] = deepClone(obj[i])
              } else {
                  ret[i] = obj[i]
              }
          }
      }
      return ret
  }
  ```

- 深度优先遍历 DFS (**Depth-First-Search**)，递归或栈

  ```js
  // 如果是对象/数组，返回一个空的对象/数组，
  // 都不是的话直接返回原对象
  // 判断返回的对象和原有对象是否相同就可以知道是否需要继续深拷贝
  // 处理其他的数据类型的话就在这里加判断
  function getEmpty(o){
  	if(Object.prototype.toString.call(o) === '[object Object]'){
  		return {};
  	}
  	if(Object.prototype.toString.call(o) === '[object Array]'){
  		return [];
  	}
  	return o;
  }
  
  function deepCopyDFS(origin){
  	let stack = [];
  	let map = new Map(); // 记录出现过的对象，用于处理环(循环引用)
  
  	let target = getEmpty(origin);
  	if(target !== origin){
  		stack.push([origin, target]);
  		map.set(origin, target);
  	}
  
  	while(stack.length){
  		let [ori, tar] = stack.pop();
  		for(let key in ori){
  			// 处理环状
  			if(map.get(ori[key])){
  				tar[key] = map.get(ori[key]);
  				continue;
  			}
  
  			tar[key] = getEmpty(ori[key]);
  			if(tar[key] !== ori[key]){
  				stack.push([ori[key], tar[key]]);
  				map.set(ori[key], tar[key]);
  			}
  		}
  	}
  
  	return target;
  }
  ```

- 广度优先遍历 BFS (**Breadth-First-Seach**)，队列

  ```js
  // 如果是对象/数组，返回一个空的对象/数组，
  // 都不是的话直接返回原对象
  // 判断返回的对象和原有对象是否相同就可以知道是否需要继续深拷贝
  // 处理其他的数据类型的话就在这里加判断
  function getEmpty(o){
  	if(Object.prototype.toString.call(o) === '[object Object]'){
  		return {};
  	}
  	if(Object.prototype.toString.call(o) === '[object Array]'){
  		return [];
  	}
  	return o;
  }
  
  function deepCopyBFS(origin){
  	let queue = [];
  	let map = new Map(); // 记录出现过的对象，用于处理环(循环引用)
  
  	let target = getEmpty(origin);
  	if(target !== origin){
  		queue.push([origin, target]);
  		map.set(origin, target);
  	}
  
  	while(queue.length){
  		let [ori, tar] = queue.shift();
  		for(let key in ori){
  			// 处理环状
  			if(map.get(ori[key])){
  				tar[key] = map.get(ori[key]);
  				continue;
  			}
  
  			tar[key] = getEmpty(ori[key]);
  			if(tar[key] !== ori[key]){
  				queue.push([ori[key], tar[key]]);
  				map.set(ori[key], tar[key]);
  			}
  		}
  	}
  
  	return target;
  }
  ```

  

## 12、格式化时间戳

```js
function formatTime(date, format) {
    date = typeof date === 'number' ? new Date(date) : date
    let o = {
        'M+': date.getMonth() + 1,
        'd+': date.getDate(),
        'h+': date.getHours(),
        'm+': date.getMinutes(),
        's+': date.getSeconds()
    }
    if (/(y+)/i.test(format)) {
        format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))
    }
    for (let k in o) {
        if (new RegExp('(' + k + ')').test(format)) {
            format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length))
        }
    }
    return format
}

formatTime(Date.now(), 'yyyy-MM-dd hh:mm:ss')
```

```js
const formatTime = (date) => {
    const year = date.getFullYear()
    const month = date.getMonth() + 1
    const day = date.getDate()
    const hour = date.getHours()
    const minute = date.getMinutes()
    const second = date.getSeconds()

    return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')
}

const formatNumber = n => {
    n = n.toString()
    return n[1] ? n : '0' + n
}
```

## 13、instanceof

```js
function _instanceof(left, right) {
    if (left == null) return false
    let proto = left.__proto__
    let p = right.prototype
    while(proto) {
        if (proto === p) return true
        proto = proto.__proto__
    }
    return false
}
```

