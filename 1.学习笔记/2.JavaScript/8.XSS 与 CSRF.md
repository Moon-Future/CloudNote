## XSS（跨站脚本攻击）

XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS 攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于 DOM。

### 反射型

反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接（攻击者可以将恶意链接直接发送给受信任用户，发送的方式有很多种，比如 email, 网站的私信、评论等，攻击者可以购买存在漏洞网站的广告，将恶意链接插入在广告的链接中）

**用户通过 Web 客户端提交给服务端的数据，立刻用于解析和显示该用户的结果页面(数据没有在服务端存储)**。如果提交的数据中含有恶意的脚本代码，而服务端没有经过编码转换或者过滤，就会形成 XSS 攻击，这种形式的 XSS 称为反射型 XSS。

常见的通过浏览器地址栏输入的 HTTP GET 请求参数和页面搜索框输入的 POST 查询内容。恶意用户通过构造含恶意脚本的 URL, 发送到各种群、朋友圈、邮箱，诱导用户点击，获取点击用户的信息，达到攻击目的。

### 存储型

**用户通过 Web 客户端提交给服务端的数据，由服务端保存，然后永久显示在其他用户的页面上。**如果提交的数据中含有恶意的脚本代码，而服务端在存储前或展示前没有经过编码转换或者过滤，就会形成 XSS 攻击，这种形式的 XSS 称为存储型 XSS。

这种场景通常是用户的留言、评论中含有恶意脚本，存储在了服务器中，普通用户访问到就会受到攻击，理论上该 Web 应用的任何用户都是攻击对象。

### 基于 DOM

基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击

## XSS攻击防范

**HttpOnly 防止劫取 Cookie**：浏览器将禁止页面的 Javascript 访问带有 HttpOnly 属性的Cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

**输入检查**：不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。

**输出检查**：用户的输入会存在问题，服务端的输出也会存在问题。在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。

## CSRF/XSRF（跨站请求伪造）

CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

> 在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。（攻击者的网站虽然是跨域的，但是他构造的链接是源网站的，跟源网站是同源的，所以能够携带 cookie 发起访问）。
>
> 但是攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。例如删除数据、修改数据，新增数据等，无法获取数据。

## CSRF 攻击防范

**验证码**：验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。

**Referer Check**：根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。

**添加 token 验证**：要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

## Cookie 的 SameSite 属性

[Cookie 的 SameSite 属性](https://juejin.im/post/6844904095711494151)