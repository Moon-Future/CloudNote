## 依赖包

```shell
npm install webpack webpack-cli -D
```



## 模式

### mode: development

```js
// webpack.development.config.js
module.exports = {
+ mode: 'development'
- plugins: [
-   new webpack.NamedModulesPlugin(),
-   new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("development") }),
- ]
}
```

### mode: production

```js
// webpack.production.config.js
module.exports = {
+  mode: 'production',
-  plugins: [
-    new UglifyJsPlugin(/* ... */),
-    new webpack.DefinePlugin({ "process.env.NODE_ENV": JSON.stringify("production") }),
-    new webpack.optimize.ModuleConcatenationPlugin(),
-    new webpack.NoEmitOnErrorsPlugin()
-  ]
}
```



## 配置文件模板

```js
module.exports = {
    entry: '',               // 入口文件
    output: {},              // 出口文件
    optimization: {},		 // 优化项
    module: {},              // 处理对应模块
    plugins: [],             // 对应的插件
    devServer: {},           // 开发服务器配置
    mode: 'development'      // 模式配置
}
```

### 单入口

```js
const { resolve } = require('path')

module.exports = {
    mode: 'development', // 'production' | 'development' | 'none'，默认 production
    entry: './src/index.js',
    output: {
        // 添加hash可以防止文件缓存，每次都会生成4位的hash串
        // hash根据文件内容算出，内容不变，hash不变
        filename: 'bundle.[hash:4].js',
        path: resolve(__dirname, 'dist'),
    }, 
}
```

### 多入口

```js
const { resolve } = require('path')

// 1. 多个文件打包到一起，实现多个文件打包
module.exports = {
    // 写成数组的方式就可以打出多入口文件，不过这里打包后的文件都合成了一个
    entry: ['.src/index.js', './src/login.js'],
    output: {
        filename: 'bundle.js',
        path: resolve(__dirname, 'dist'),
    },
}

// 2. 真正实现多入口和多出口需要写成对象的方式
module.exports = {
    mode: 'development', // 'production' | 'development' | 'none'，默认 production
    entry: {
        index: './src/index.js',
        login: './src/login.js',
    },
    output: {
        // [name] 可以将出口文件与入口文件一一对应
        filename: '[name].js', // 打包后生成 index.js 和 login.js 文件
        path: resolve(__dirname, 'dist'),
    },
}
```



## Loader

> *loader* 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。

在更高层面，在 webpack 的配置中 **loader** 有两个目标：

1. `test` 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。
2. `use` 属性，表示进行转换时，应该使用哪个 loader。（从右向左）

**用法**：

[`module.rules`](https://www.webpackjs.com/configuration/module/#module-rules) 允许你在 webpack 配置中指定多个 loader

```js
module: {
    rules: [
        {
            test: /\.(scss|sass)$/,
            // 先执行 sass-loader，再执行 css-loader，最后执行 style-loader
            use: ['style-loader', 'css-loader', 'sass-loader'],
        },
    ],
},
```

或者

```js
module: {
    rules: [
        {
            test: /\.css$/,
            use: [
                { loader: 'style-loader' },
                {
                    loader: 'css-loader',
                    options: {
                        modules: true
                    }
                },
                {
                    loader: 'sass-loader'
                }
            ]
        }
    ]
}
```

或者

```js
moduels: {
    rules: [
        {
            test: /\.js$/,
        	loader: 'babel-loader'
        }
    ]
}
```



## 常用 Loader

### style-loader，css-loader，sass-loader

```shell
npm i style-loader css-loader sass-loader node-sass -D
```

先使用 sass-loader 将 .sass 或 .scss 文件转换成 css，再使用 css-loader 加载 css 文件，最后使用 style-loader 将 css-loader 处理的样式**注入到 HTML 页面中**。

> style-loader：把 js 中 import 导入的样式文件打包到 js 文件中，**运行 js 文件时**，将样式自动插入到<style>标签中。

```js
module: {
    rules: [
        {
            test: /\.css$/, // 解析css
            use: ['style-loader', 'css-loader', 'sass-loader'], // 从左向右解析
        },
    ],
},
```

### file-loader，url-loader

```shell
npm i file-loader url-loader -D
```

在入口文件中引入图片 `import ajpg from './a.jpg'` 或者 import 进的样式中包含图片，需通过 file-loader 或者 url-loader 来解析，否则或报错 `You may need an appropriate loader to handle this file type ...`

```js
module: {
    rules: [
        {
            test: /\.(png|jpg|gif)$/,
            use: [
                {
                    loader: 'file-loader',
                    options: { // 默认文件，dist文件夹下
                        name: '[name].[hash].[ext]', // ext 图片后缀
                        outputPath: 'images/',
                    }
                },
            ],
        },
    ],
},
```

- **file-loader** 用来解析 js 或 css 中的图片，在打包时一定会生成单独的文件

- **url-loader** （url-loader 内部依赖于 file-loader）除了可以做 file-loader 能做的事情，还可以通过配置规则将一定范围大小的图片打包成 base64 的字符串，放到打包好的 js 中，而不是单独生成一个图片文件，从而较少 http 请求。**当图片大于配置范围时，会调用 file-loader 来解析，所以使用 url-loader 必须也要安装 file-loader 依赖** `npm i file-loader url-loader -D`

```js
module: {
    rules: [
        {
            test: /\.(png|jpg|gif)$/,
            use: [
                {
                    loader: 'url-loader',
                    options: {
                        name: '[name].[hash].[ext]', // ext 图片后缀
                        outputPath: 'images/',
                        limit: 8192, // 小于8k的图片自动转成base64格式，并且不会存在实体图片
                    },
                },
            ],
        },
    ]
}
```

url-loader 默认将所有图片打包成 base64，若图片太大，打包后的 js 就会很大，所以最好设定好 limit。

字体图标和 svg 图片都可以通过 file-loader 或 url-loader 来解析

```js
module: {
    rules: [
        {
            test: /\.(eot|ttf|woff|svg)$/,
            use: 'file-loader' // 或者 url-loader
        }
    ]
}
```

### html-withimg-loader

```shell
npm i html-withimg-loader -D
```

> file-loader，url-loader 可处理 js 和 import 进的 css (区别去 html 中手动引入的 css) 中的图片
>
> 页面中使用的 img 标签引用的图片地址需要 html-withimg-loader 来帮我们处理

```js
module: {
    rules: [
        {
            test: /\.(htm|html)$/,
            use: 'html-withimg-loader',
        },
    ]
}
```

若打包后的 img 标签不正确 `<img src={"default":"images/b.740fd71e606c553b4cc043b5f9f51895.jpg"} alt="" />`，需在处理图片的 file-loader 或 url-loader 里增加选项 esModule: false

> file-loader 新版本默认使用了 esModule 语法，造成了引用图片文件时的方式和以前的版本不一样

所以：

```js
module: {
    rules: [
        {
            test: /\.(png|jpg|gif)$/,
            use: [
                {
                    loader: 'url-loader',
                    options: {
                        name: '[name].[hash].[ext]', // ext 图片后缀
                        outputPath: 'images/',
                        limit: 8192, // 小于8k的图片自动转成base64格式，并且不会存在实体图片
                        esModule: false,
                    },
                },
            ],
        },
        {
            test: /\.(htm|html)$/,
            use: 'html-withimg-loader',
        },
    ]
}
```

### postcss-loader，autoprefixer

```sh
npm i postcss-loader autoprefixer -D
```

> 通过 postcss 中的 autoprefixer 可以实现将 CSS3 中的一些需要兼容写法的属性添加响应的前缀，这样省去我们不少的时间

在 webpack.config.js 同级下创建文件 postcss.config.js

```js
// postcss.config.js
module.exports = {
  plugins: [require('autoprefixer')], // 引用该插件即可了
}
```

```js
// webpack.config.js
module: {
    rules: [
        {
            test: /\.css$/, // 解析css
            // use: ['style-loader', 'css-loader', 'sass-loader'], // 从左向右解析
            // 使用 mini-css-extract-plugin 后，就不用 style-loader
            use: [
                {
                    loader: MiniCssExtractPlugin.loader,
                },
                'css-loader',
                'postcss-loader',
                'sass-loader',
            ],
        },
    ]
}
```

若打包时报错 `PostCSS plugin autoprefixer requires PostCSS 8`，降级 autoprefixer: ^9.8.6

```shell
npm uninstall autoprefixer -D
npm i autoprefixer@9.8.6 -D
```

### babel

> **Babel 是一个 JavaScript 编译器**
>
> Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

方法一：

```shell
npm i babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime -D
npm i @babel/runtime -S
## @babel/plugin-transform-runtime 依赖于 @babel/runtime
```

```js
// .babelrc
{
    "presets": [
        "@babel/preset-env"
    ],
    "plugins": [
        "@babel/plugin-transform-runtime"
    ]
}

// webpack.config.js
moduels: {
    rules: [
        {
            test: /\.js$/,
        	loader: 'babel-loader'
        }
    ]
}
```

方法二：

```shell
npm i @babel/core babel-loader @babel/preset-env -D
```

```js
module: {
    rules: [
        {
            test:/\.js$/,
            use: {
                loader: 'babel-loader',
                // 配置选项里的presets
                // 包含ES6还有之后的版本和那些仅仅是草案的内容
                options: {
                    presets: ['@babel/preset-env']
                }
            }
            include: /src/,          // 只转化src目录下的js
            exclude: /node_modules/  // 排除掉node_modules，优化打包速度
        }
    ]
}
```



## 常用 Plugin

### html-webpack-plugin

> 基于 html 模板生成打包后的 html 文件

```shell
npm i html-webpack-plugin -D
```

```js
const { resolve } = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

// 单入口
plugins: [
    new HtmlWebpackPlugin({
        template: resolve(__dirname, 'src/index.html'),
        filename: 'index.html',
        hash: true, // 会在打包好的bundle.js后面加上完整hash串(bundle.js?xxxxxxxxxx)
    })
]

// 多入口
plugins: [
    new HtmlWebpackPlugin({
        template: './src/index.html',
        filename: 'index.html',
        chunks: ['index'], // 对应关系,index.js对应的是index.html
    }),
    new HtmlWebpackPlugin({
        template: './src/login.html',
        filename: 'login.html',
        chunks: ['login'], // 对应关系,login.js对应的是login.html
    }),
],
```

### webpack-dev-server

> 热编译，热刷新 HMR（HotModuleReplacement）

```shell
npm i webpack-dev-server -D
```

```js
const webpack = require('webpack')

{
    //  可选，如果打包路径不是 dist 可在此修改
    devServer: {
        contentBase: './dist',
        host: 'localhost',      // 默认是localhost
        port: 3000,             // 端口
        open: true,             // 自动打开浏览器
        hot: true               // 开启热更新
    },

    plugins: [
        // 热更新，热更新不是刷新
        new webpack.HotModuleReplacementPlugin()
    ]
}

// 此时还没完虽然配置了插件和开启了热更新，但实际上并不会生效
// 还需要在主要的js文件里写入下面这段代码
// index.js
if (module.hot) {
    // 实现热更新，只重新加载修改过的文件，不会刷新整个页面
    module.hot.accept();
}

// package.json
"scripts": {
    "hot": "webpack-dev-server"
},
```

`webpack --watch` 可以监听文件变化，热编译，但无法刷新页面（热刷新）

### clean-webpack-plugin

> 清除构建文件夹（dist）

```js
plugins: [
    new CleanWebpackPlugin(),
],
```

### copy-webpack-plugin

> 复制静态资源文件

```js
plugins: [
    new CopyWebpackPlugin([
        // {output}/file.txt
        { from: 'from/file.txt' },

        // equivalent
        'from/file.txt',

        // {output}/to/file.txt
        { from: 'from/file.txt', to: 'to/file.txt' },

        // {output}/to/directory/file.txt
        { from: 'from/file.txt', to: 'to/directory' },

        // Copy directory contents to {output}/
        { from: 'from/directory' },

        // Copy directory contents to {output}/to/directory/
        { from: 'from/directory', to: 'to/directory' },

        // Copy glob results to /absolute/path/
        { from: 'from/directory/**/*', to: '/absolute/path' },

        // Copy glob results (with dot files) to /absolute/path/
        {
            from: {
                glob:'from/directory/**/*',
                dot: true
            },
            to: '/absolute/path'
        },

        // Copy glob results, relative to context
        {
            context: 'from/directory',
            from: '**/*',
            to: '/absolute/path'
        },

        // {output}/file/without/extension
        {
            from: 'path/to/file.txt',
            to: 'file/without/extension',
            toType: 'file'
        },

        // {output}/directory/with/extension.ext/file.txt
        {
            from: 'path/to/file.txt',
            to: 'directory/with/extension.ext',
            toType: 'dir'
        }
    ], {
        ignore: [
            // Doesn't copy any files with a txt extension    
            '*.txt',

            // Doesn't copy any file, even if they start with a dot
            '**/*',

            // Doesn't copy any file, except if they start with a dot
            { glob: '**/*', dot: false }
        ],

        // By default, we only copy modified files during
        // a watch or webpack-dev-server build. Setting this
        // to `true` copies all files.
        copyUnmodified: true
    })
]
```

### mini-css-extract-plugin

> 将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 sourceMap
>
> extract-text-webpack-plugin 已不推荐使用

- **style-loader**：把 js 中 import 导入的样式文件打包到 js 文件中，***运行 js 文件时***，将样式自动插入到 <style> 标签中。

- **mini-css-extract-plugin**：把 js 中 import 导入的样式文件，单独打包成一个 css 文件，结合 html-webpack-plugin，***以 link 的形式插入到 html 文件中***。
  **注**：此插件不支持HMR，若修改了样式文件，是不能即时在浏览器中显示出来的，需要手动刷新页面。

如果使用了 `mini-css-extract-plugin` 插件，就可以不用 style-loader 了

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

module: {
    rules: [
      {
        test: /\.css$/, // 解析css
        // use: ['style-loader', 'css-loader', 'sass-loader'], // 从左向右解析
        // 使用 mini-css-extract-plugin 后，就不用 style-loader
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
          },
          'css-loader',
          'sass-loader',
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].css', // 多入口文件时，[name] 和 output [name] 一样，单入口文件，若不设置固定名，则默认为 main.css
    })
  ],
```

### optimize-css-assets-webpack-plugin

> 压缩 CSS

### terser-webpack-plugin

```shell
npm i terser-webpack-plugin -D
```

> 压缩混淆 js，uglifyjs-js-webpack-plugin 不支持 es6 语法

```js
const TerserPlugin = require('terser-webpack-plugin')

module.exports = {
    optimization: {
        minimize: true,
        minimizer: [new TerserPlugin({
            test: /\.js(\?.*)?$/i,
        })],
    },
}
```



## resolve 解析

在 webpack 的配置中，resolve 我们常用来配置别名和省略后缀名

```js
module.exports = {
    resolve: {
        // 别名
        alias: {
            $: './src/jquery.js',
            '@': './src'
        },
        // 省略后缀
        extensions: ['.js', '.json', '.css']
    },
}
```



## 提取公共代码