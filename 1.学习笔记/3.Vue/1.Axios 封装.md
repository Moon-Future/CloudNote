## axios Â∞ÅË£Ö

### http.js

```js
import store from '@/store/index'
import axios from 'axios'
import router from '../router/index'
import { Loading, Message } from 'element-ui'

const tip = (msg, type = 'info') => {
  Message({
    message: msg,
    duration: 1000,
    type,
    center: true
  })
}

/**
 * Ë∑≥ËΩ¨ÁôªÂΩïÈ°µ
 * Êê∫Â∏¶ÂΩìÂâçÈ°µÈù¢Ë∑ØÁî±Ôºå‰ª•ÊúüÂú®ÁôªÂΩïÈ°µÈù¢ÂÆåÊàêÁôªÂΩïÂêéËøîÂõûÂΩìÂâçÈ°µÈù¢
 */
const toLogin = () => {
  router.replace({
    path: '/login',
    query: {
      redirect: router.currentRoute.fullPath
    }
  })
}

/**
 * ËØ∑Ê±ÇÂ§±Ë¥•ÂêéÁöÑÈîôËØØÁªü‰∏ÄÂ§ÑÁêÜ
 * @param {Number} status ËØ∑Ê±ÇÂ§±Ë¥•ÁöÑÁä∂ÊÄÅÁ†Å
 */
const errorHandle = (status, message) => {
  // Áä∂ÊÄÅÁ†ÅÂà§Êñ≠
  switch (status) {
    // 400
    case 400:
      tip(message)
      break
    // 401: Êú™ÁôªÂΩïÁä∂ÊÄÅÔºåË∑≥ËΩ¨ÁôªÂΩïÈ°µ
    case 401:
      toLogin()
      break
    // 403 token ËøáÊúü
    // Ê∏ÖÈô§ token Âπ∂Ë∑≥ËΩ¨ÁôªÂΩïÈ°µ
    case 403:
      tip('ÁôªÂΩïËøáÊúüÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï', 'error')
      localStorage.removeItem('token')
      // store.commit('loginSuccess', null)
      // setTimeout(() => {
      //   toLogin()
      // }, 1000)
      break
    // 404 ËØ∑Ê±Ç‰∏çÂ≠òÂú®
    case 404:
      tip('ËØ∑Ê±ÇÁöÑËµÑÊ∫ê‰∏çÂ≠òÂú®', 'error')
      break
    case 500:
      tip('ÊúçÂä°Âô®ÂºÄÂ∞èÂ∑ÆÂï¶üòÖ', 'error')
      break
    default:
      console.log(message)
  }
}

let instance = axios.create({ timeout: 1000 * 12 })
let CancelToken = axios.CancelToken
let pending = {}
instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'

function removePending(key, isRequest = false) {
  if (pending[key] && isRequest) {
    pending[key]('ÂèñÊ∂àÈáçÂ§çËØ∑Ê±Ç')
  }
  delete pending[key]
}

instance.interceptors.request.use(
  config => {
    // ÂèñÊ∂àÈáçÂ§çËØ∑Ê±Ç
    removePending(config.url + '&' + config.method, true)
    config.cancelToken = new CancelToken(c => {
      pending[config.url + '&' + config.method] = c
    })
    // ÊØèÊ¨°ÂèëÈÄÅËØ∑Ê±Ç‰πãÂâçÂà§Êñ≠ vuex ‰∏≠ÊòØÂê¶Â≠òÂú® token
    // Â¶ÇÊûúÂ≠òÂú®ÔºåÂàôÁªü‰∏ÄÂú® http ËØ∑Ê±ÇÁöÑ header ÈÉΩÂä†‰∏ä tokenÔºåËøôÊ†∑ÂêéÂè∞Ê†πÊçÆ token Âà§Êñ≠‰Ω†ÁöÑÁôªÂΩïÊÉÖÂÜµ
    // Âç≥‰ΩøÊú¨Âú∞Â≠òÂú® tokenÔºå‰πüÊúâÂèØËÉΩ token ÊòØËøáÊúüÁöÑÔºåÊâÄ‰ª•Âú®ÂìçÂ∫îÊã¶Êà™Âô®‰∏≠Ë¶ÅÂØπËøîÂõûÁä∂ÊÄÅËøõË°åÂà§Êñ≠
    const token = store.state.token
    token && (config.headers.Authorization = token)
    return config
  },
  error => {
    return Promise.error(error)
  }
)

instance.interceptors.response.use(
  res => {
    removePending(res.config.url + '&' + res.config.method)
    // Â¶ÇÊûúËøîÂõûÁöÑÁä∂ÊÄÅÁ†Å‰∏∫200ÔºåËØ¥ÊòéÊé•Âè£ËØ∑Ê±ÇÊàêÂäüÔºåÂèØ‰ª•Ê≠£Â∏∏ÊãøÂà∞Êï∞ÊçÆ
    // Âê¶ÂàôÁöÑËØùÊäõÂá∫ÈîôËØØ
    if (res.status === 200) {
      res.data.message && tip(res.data.message, 'success')
      return Promise.resolve(res)
    } else {
      return Promise.reject(res)
    }
  },
  // ÊúçÂä°Âô®Áä∂ÊÄÅÁ†Å‰∏çÊòØ2ÂºÄÂ§¥ÁöÑÁöÑÊÉÖÂÜµ
  // ËøôÈáåÂèØ‰ª•Ë∑ü‰Ω†‰ª¨ÁöÑÂêéÂè∞ÂºÄÂèë‰∫∫ÂëòÂçèÂïÜÂ•ΩÁªü‰∏ÄÁöÑÈîôËØØÁä∂ÊÄÅÁ†Å
  // ÁÑ∂ÂêéÊ†πÊçÆËøîÂõûÁöÑÁä∂ÊÄÅÁ†ÅËøõË°å‰∏Ä‰∫õÊìç‰ΩúÔºå‰æãÂ¶ÇÁôªÂΩïËøáÊúüÊèêÁ§∫ÔºåÈîôËØØÊèêÁ§∫Á≠âÁ≠â
  // ‰∏ãÈù¢Âàó‰∏æÂá†‰∏™Â∏∏ËßÅÁöÑÊìç‰ΩúÔºåÂÖ∂‰ªñÈúÄÊ±ÇÂèØËá™Ë°åÊâ©Â±ï
  error => {
    const { response } = error
    if (response) {
      removePending(response.config.url + '&' + response.config.method)
      // ËØ∑Ê±ÇÂ∑≤ÂèëÂá∫Ôºå‰ΩÜÊòØ‰∏çÂú®2xxÁöÑËåÉÂõ¥
      errorHandle(response.status, response.data.message)
      return Promise.reject(response)
    } else {
      // Â§ÑÁêÜÊñ≠ÁΩëÁöÑÊÉÖÂÜµ
      // eg:ËØ∑Ê±ÇË∂ÖÊó∂ÊàñÊñ≠ÁΩëÊó∂ÔºåÊõ¥Êñ∞ state ÁöÑ network Áä∂ÊÄÅ
      // network Áä∂ÊÄÅÂú® app.vue ‰∏≠ÊéßÂà∂ÁùÄ‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑÊñ≠ÁΩëÊèêÁ§∫ÁªÑ‰ª∂ÁöÑÊòæÁ§∫ÈöêËóè
      // ÂÖ≥‰∫éÊñ≠ÁΩëÁªÑ‰ª∂‰∏≠ÁöÑÂà∑Êñ∞ÈáçÊñ∞Ëé∑ÂèñÊï∞ÊçÆÔºå‰ºöÂú®Êñ≠ÁΩëÁªÑ‰ª∂‰∏≠ËØ¥Êòé
      // store.commit('changeNetwork', false)
    }
  }
)

export default instance
```

### api.js

```js
import http from './http'

export const URL = {
  // Áî®Êà∑
  register: '/api/user/register', // Áî®Êà∑Ê≥®ÂÜå
  login: '/api/user/login' // Áî®Êà∑ÁôªÈôÜ
}

const API = {
  /**
   * Áî®Êà∑Ê≥®ÂÜå
   * @param {Object} data {username, password, rePassword, nickname, emailCode} Áî®Êà∑Âêç ÂØÜÁ†Å ÈáçÂ§çÂØÜÁ†Å ÊòµÁß∞ ÈÇÆÁÆ±È™åËØÅÁ†Å
   */
  register(data) {
    return http.post(URL.register, data)
  },

  /**
   * Áî®Êà∑ÁôªÈôÜ
   * @param {String} username Áî®Êà∑Âêç
   * @param {String} password ÂØÜÁ†Å
   */
  login(username, password) {
    return http.post(URL.login, { username, password })
  }
}

export default API
```

## axios ÁÆÄÊòìÁâàÂÆûÁé∞

Êï¥‰ΩìÁªìÊûÑÔºö

```js
/**
 * Axios ÁÆÄÊòìÁâàÂÆûÁé∞
 */

class Axios {
    constructor() {
        // ÂÆö‰πâÊã¶Êà™Âô®ÂØπË±°
        this.interceptors = {}
        // ÈªòËÆ§ÁöÑÈÖçÁΩÆÊñá‰ª∂
        this.config = {}
    }

    // axios ÂàùÂßãÂåñÂáΩÊï∞ÔºåÂØπ config ËøõË°åËµãÂÄº
    static create() {}

    // ËØ∑Ê±ÇÂèëÈÄÅÂâçÁöÑÊã¶Êà™ÂáΩÊï∞
    beforeRequest() {}

    // ËØ∑Ê±ÇÂìçÂ∫îÁöÑÊã¶Êà™ÂáΩÊï∞
    beforeResponse() {}

    // ÈÄöÁî® request ÂáΩÊï∞
    async request() {}

    // ÁúüÊ≠£ÂèëËØ∑Ê±ÇÁöÑÂáΩÊï∞
    sendRequest() {}

    get() {}

    post() {}
}
```

ËØ¶Ôºö

```js
/**
 * Axios ÁÆÄÊòìÁâàÂÆûÁé∞
 */

class Axios {
    constructor() {
        // ÂÆö‰πâÊã¶Êà™Âô®ÂØπË±°
        this.interceptors = {
            // ËØ∑Ê±ÇÊã¶Êà™
            request: {
                // ÁªôÂáΩÊï∞ÁªëÂÆöÂΩìÂâçÁöÑ thisÔºåÂê¶Ê≠£ this ÊåáÂêë request
                use: this.beforeRequest.bind(this),
                success: function () {},
                fail: function () {},
            },

            // ÂìçÂ∫îÊã¶Êà™
            response: {
                use: this.beforeResponse.bind(this),
                success: function () {},
                fail: function () {},
            },
        }
        // ÈªòËÆ§ÁöÑÈÖçÁΩÆÊñá‰ª∂
        this.config = {
            // ËØ∑Ê±ÇÁöÑÂü∫Á°ÄË∑ØÁî±
            baseUrl: 'http://127.0.0.1/',
            timeout: 6000,
            method: 'GET',
            dataType: 'JSON',
            responseType: 'text',
            Authorization: '',
            ContentType: 'application/json',
        }
    }

    /**
   * axios ÁöÑÂàùÂßãÂåñÂáΩÊï∞ÔºåÂàùÂßãÂåñÊó∂ÂØπ config ËøõË°åËµãÂÄº
   * ÂΩìÂèÇÊï∞Ê≤°Êúâ‰º†ÂÖ•Êó∂Ôºå‰ΩøÁî®ÈªòËÆ§ÂèÇÊï∞
   * @param baseURL
   * @param timeout
   * @param method
   * @param dataType
   * @param responseType
   * @param ContentType
   * @param Authorization
   */
    static create({
        baseURL = '',
        timeout = 5000,
        method = 'GET',
        dataType = 'json',
        responseType = 'text',
        ContentType = 'application/json',
        Authorization = '',
    } = {}) {
        const axios = new Axios()
        axios.config = {
            baseURL,
            timeout,
            method,
            dataType,
            responseType,
            ContentType,
            Authorization,
        }
    }

    // ËØ∑Ê±ÇÂèëÈÄÅÂâçÁöÑÊã¶Êà™ÂáΩÊï∞
    beforeRequest(successFunc, failFunc) {
        /**
     * ÊàêÂäüÊã¶Êà™ÂáΩÊï∞Ôºå‰º†ÂÖ•‰∏Ä‰∏™config
     * Ë∞ÉÁî®Êã¶Êà™ÁöÑÊó∂ÂÄôÔºå‰ºöË∞ÉÁî®‰º†ÂÖ•ÁöÑsuccessFuncÂáΩÊï∞
     * @param config
     */
        this.interceptors.request.success = (config) => {
            return successFunc(config)
        }
        this.interceptors.request.fail = (error) => {
            return failFunc(error)
        }
    }

    // ËØ∑Ê±ÇÂìçÂ∫îÁöÑÊã¶Êà™ÂáΩÊï∞
    beforeResponse(successFunc, failFunc) {
        this.interceptors.response.success = (config) => {
            return successFunc(config)
        }
        this.interceptors.response.fail = (error) => {
            return failFunc(error)
        }
    }

    // ÈÄöÁî® request ÂáΩÊï∞
    async request() {
        let config = this.config
        return new Promise(async (resolve, reject) => {
            // ËØ∑Ê±ÇÂâçÁöÑÊã¶Êà™Ôºå‰∏ÄÂÆöË¶ÅÁî®awaitÔºåÂõ†‰∏∫Êã¶Êà™ÂáΩÊï∞ÂèØËÉΩ‰ºöÊúâ‰∏Ä‰∫õÂºÇÊ≠•ÁöÑÊìç‰ΩúÔºåÂç≥ÊâßË°å successFunc(config)
            config = await this.interceptors.request.success(config)

            // Â¶ÇÊûúÊ≤°ÊúâËøîÂõûÂèÇÊï∞ÔºåËØ∑Ê±Ç‰∏çÂÜçÂêë‰∏ãÊâßË°å
            if (!config) return

            // Ê≠£ÂºèÂèëÈÄÅËØ∑Ê±Ç
            await this.sendRequest(config)
                .then((requestResponse) => {
                let response = {
                    statusCode: requestResponse.statusCode,
                    config,
                    data: requestResponse.data,
                    header: requestResponse.header,
                    errMsg: requestResponse.errMsg,
                }
                // ÊâßË°åÊàêÂäüÁöÑÊã¶Êà™ÂáΩÊï∞Ôºå‰º†ÂÖ•ËØ∑Ê±ÇÁöÑÁªìÊûú
                const result = this.interceptors.response.success(response)
                // ÊúâÂèØËÉΩ‰ºöËøîÂõûPromise.rejectÔºåÊâÄ‰ª•Ë¶ÅÂà§Êñ≠ÊòØ‰∏çÊòØPromise
                if (this._checkIsPromise(result)) {
                    result.catch((err) => {
                        reject(err)
                    })
                } else {
                    resolve(result)
                }
            })
                .catch((requestError) => {
                let error = {
                    error: requestError,
                    response: {
                        statusCode: requestError.statusCode,
                        config,
                        data: requestError.data,
                        header: requestError.header,
                        errMsg: requestError.errMsg,
                    },
                }
                // ÊâßË°åÂ§±Ë¥•ÁöÑÊã¶Êà™ÂáΩÊï∞
                const failResult = this.interceptors.response.fail(error)
                if (this._checkIsPromise(failResult)) {
                    failResult.catch((err) => {
                        reject(err)
                    })
                } else {
                    reject(failResult)
                }
            })
        })
    }

    // ÁúüÊ≠£ÂèëËØ∑Ê±ÇÁöÑÂáΩÊï∞
    sendRequest(config) {
        return new Promise((resolve, reject) => {
            request({
                // Â¶ÇÊûúÊòØÊ∫êËØ∑Ê±ÇÔºåÂàô‰∏çÂÜçÊ∑ªÂä†baseURL
                url: config.url,
                method: config.method,
                data: config.data,
                dataType: config.dataType,
                timeout: config.timeout,
                // responseType: config.responseType,
                header: {
                    'Content-Type': config.ContentType,
                    Authorization: config.Authorization,
                },
                success: (res) => {
                    // 404Áä∂ÊÄÅÁ†ÅÔºåÂàôËÆ©ÂÆÉËµ∞failÂõûË∞É
                    if (res.statusCode === 404) {
                        reject(res)
                        return
                    }
                    resolve(res)
                },
                fail: (err) => {
                    reject(err)
                },
            })
        })
    }

    get() {}

    post() {}

    // Ê£ÄÊü•ÊòØÂê¶‰∏∫Promise
    _checkIsPromise(obj) {
        if (!obj) return
        return Object.toString.call(obj) === '[object Promise]'
    }
}
```

## ÂèñÊ∂àËØ∑Ê±ÇÊ∫êÁ†Å

[axios ‰πãcancelTokenÂéüÁêÜ‰ª•Âèä‰ΩøÁî®](https://www.cnblogs.com/ysk123/p/11544211.html)

```js
// CancelToken.js
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
    if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
        if (token.reason) {
            // Cancellation has already been requested
            return;
        }

        token.reason = new Cancel(message);
        resolvePromise(token.reason);
    });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
        throw this.reason;
    }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};

module.exports = CancelToken;
```

