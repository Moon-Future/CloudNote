## 1. Vue2.0 / 3.0 双向数据绑定原理

我们现在项目中都还在使用 Vue2.0，自己也做过很多实战项目，在了解了一定程度后，我开始研究 Vue2.0 的底层实现原理，发现 Vue2.0 的双向绑定就是通过 ES5 新加的一个叫 defineProperty 的属性来进行数据劫持从而实现的。

后来又在尤大大知乎上了解到 Vue3.0 已经进入了内测版本，然后特意去下了 Vue3.0 的源码，又在掘金等技术网上关注大家对 3.0 的评价，我感觉 3.0 对于 2.0 来说就是一个很大的跨越（跨时代的意义）。

3.0 的双向数据绑定是通过 proxy 来实现的，这样做相对于 2.0 来说有这些好处：而且还有其他好处。。。

## 2. 什么是 MVVM

> Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表

首先什么是 MVC ？MVC 是三个单词的首字母缩写：

- M：Model（数据模型）
- V：View（UI视图）
- C：Controller（逻辑控制）

MVVM 是 **Model-View-ViewModel** 的缩写。MVVM 是一种设计思想。Model 层代表**数据模型**，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 **UI 组件**，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

（1）View 层

View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。

（2）Model 层

Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。

（3）ViewModel 层

ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。

MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。

## 3. 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。

> 因为不带 key 时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改 DOM 文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”。
> 
> 既然如此，为什么还要建议带 key 呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。
> 
> 举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过 tab 切换“娱乐新闻”或是“社会新闻”。
> 
> 不带 key 属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻 id 作为唯一 key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。
> 
> 这只是个简单的例子，实际应用会更复杂。带上唯一 key 虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一 id 作为 key 的原因。至于具体怎么使用，就要根据实际情况来选择了。

> key 的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。另外，某些情况下**不带 key 可能性能更好**

## 4. Virtual Dom 的优势在哪里

「Virtual Dom 的优势」其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果DOM操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。

首先我们需要知道：

- DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）
- JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，
- 引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。

其次是 VDOM 和真实 DOM 的区别和优化：

- 虚拟 DOM 不会立马进行排版与重绘操作
- 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗
- 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部

## 5、比较下 React 和 Vue

相同点：

- 都有组件化开发和 Virtual Dom
- 都支持 props 进行父子组件间数据通信
- 都支持数据驱动视图，不直接操作真实 DOM，更新状态数据，界面就更新
- 都支持服务端渲染
- 都有支持 native 的方案，React 的 React Native，Vue 的 Weex

不同点：

- 数据绑定：Vue 实现了数据的双向绑定，React 的数据流动是单向的
- 组件写法不一样，React 推荐的做法是 JSX，也就是把 HTML 和 CSS 全都写进 JavaScript，即 “all in js”；Vue 推荐的做法是 webpack+vue-loader 的单文件组件格式，即 HTML、CSS、JS 写在同一个文件

## 6、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。

为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。另外，某些情况下**不带key可能性能更好**

## 7、项目中遇到过什么问题？怎么解决的？

1. **关于定时器-01**
   
   假如，我们在A组建中声明了一个定时器进行倒计时此时 我们在定时器中一直打印时间戳，此时我们通过路由跳转到下一个组件页面，按照正常理论来说，A组件在跳转后整个组件就会被销毁，到达B组件时A组件已经没有了。
   
   但是在我们有定时器的情况下 此时跳转过后 定时器依然会存在。所以我们**要在页面销毁时候将当前页面的定时器clear掉**。

2. **关于定时器-02**
   
   有定时器的页面切出到后台（不是关闭进程），过一段时间后页面的倒计时就会出现混乱。
   
   原因：因为当我们切出到任务管理器后台时，此时在客户端中的浏览器里面，浏览器就会终止定时器因为消耗性能，当我们返回的时候此时倒计时才会恢复正常。
   
   解决：h5有一个监听浏览器页面是否隐藏的事件 **visibilitychange** 两种状态 hidden和visity hidden时候页面切出此时我们要将定时器销毁，visity时候再次恢复定时器。

3. **如何刷新当前组件页面**
   
   this.$router.push(0)

4. 样式污染
   
   **一、污染是如何产生的？**
   
   得益于 Vue-loader，在 Vue 中可以使用类似于 Web Component 的组件化写法, ，在大多数情况下，我们希望组件间定义的样式是相互隔离的，在 Weex 当中的确如此，组件天生隔离，可是在 Vue 当中，运行的载体还是浏览器，所有的样式类还是会通过 style 标签插入头部，影响全局，交叉污染
   
   **二、增加 Scoped 标识**
   
   依然是 Vue-loader，通过为组件中的 style 标签增加一个 scoped 标识，Vue-loader 在编译的过程中会为组件每一个元素节点增加 scopeId 作为属性，同时为所有的样式类加上属性选择器 scopeId，从而达到隔离的效果。
