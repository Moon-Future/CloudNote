## 1、什么是闭包？

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中变量，那么函数 B 就是闭包。

> 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
> 
> 在 JS 中，闭包存在的意义就是让我们可以间接的访问函数内部的变量。
> 
> 会导致垃圾回收机制没有把当前变量回收掉，这样的操作带来了**内存泄漏**的影响，当内存泄漏到一定程度会影响性能，甚至导致程序崩溃。因此在项目中我们要尽量避免内存泄漏。

作用：

1. 可以读取函数内部的变量

2. 让这些变量的值始终保存在内存中

## 2、什么是原型

构造函数，是一种特殊的方法，主要用来创建对象时初始化对象。

每个构造函数都有一个 prototype (原型)(箭头函数以及Function.prototype.bind() 没有)属性，这个 prototype (原型)是一个指针，指向一个对象，这个对象的用途是包含特定类型的所有实例共享的属性方法，即这个原型对象是用来给实例共享属性和方法的。

每个实例对象的 `__proto__ ` 都指向这个【构造函数/类】的 prototype 属性。 

## 3、什么是原型链？

如果我们得到一个实例化对象，当我们访问对象属性时，它会先在自身属性上查找，如果没有这个属性，就会去 `__proto__` 中查找，一层层向上查找直到顶层对象 Object，这个查找的过程就是原型链。

## 4、深拷贝浅拷贝

- **浅拷贝**：浅拷贝通过 ES6 新特性 Object.assign() 或者通过扩展运算法 ... 来达到浅拷贝的目的，浅拷贝修改副本，不会影响原数据，但缺点是浅拷贝只能拷贝第一层的数据，且都是值类型数据，如果有引用型数据，修改 副本会影响原数据。

- **深拷贝**：通过利用 JSON.parse(JSON.stringify()) 来实现深拷贝的目的，但利用 JSON 拷贝也是有缺点的， 当要拷贝的数据中含有 undefined/function/symbol 类型是无法进行拷贝的，当然我们想项目开发中需要 深拷贝的数据一般不会含有以上三种类型，如有需要可以自己在封装一个函数来实现。

## 5、JavaScript 规定了哪几种语言类型？

在 JavaScript 规范中，共定义了七种数据类型，分为 “基本类型” 和 “引用类型” 两大类，如下所示：

- **基本类型**：String、Number、Boolean、Symbol、Undefined、Null 
- **引用类型**：Object

## 6、什么是作用域链？

在 JavaScript 中，作用域分为：

**全局作用域**：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域

**函数作用域**：在固定的代码片段才能被访问

一般情况，**变量取值**在**创建这个变量的函数作用域**中取值，如果当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这个查找过程形成的链条就叫做作用域链。

> 变量对象 Variable Object（VO）
> 
> 活动对象 Activation Object（AO）
> 
> 作用域链 Scope Chain

## 7、null 和 undefined 有什么区别？

1. null 是表示一个“无”的对象，转为数值为0，undefined 是表示一个“无”的原始值，转为数值为 NaN。当声明的变量还未初始化时，变量的默认值是 undefined

2. null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象

3. undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：
   
   - 变量被声明了，但没有赋值时，就等于 undefined
   - 调用函数时，应该提供的参数没有提供，该参数等于 undefined
   - 对象没有赋值属性，该属性的值为 undefined
   - 函数没有返回值时，默认返回 undefined

4. null 表示”没有对象”，即该处不应该有值。典型用法是：
   
   - 作为函数的参数，表示该函数的参数不是对象
   - 作为对象原型链的终点

5. ```js
   null == undefined // true
   ```

## 8、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

- Set
  - 成员唯一、无序且不重复
  - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
  - 可以遍历，方法有：add、delete、has
- WeakSet
  - 成员都是对象
  - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
  - 不能遍历，方法有add、delete、has
- Map
  - 本质上是键值对的集合，类似集合
  - 可以遍历，方法很多可以跟各种数据格式转换
- WeakMap
  - 只接受对象作为键名（null除外），不接受其他类型的值作为键名
  - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
  - 不能遍历，方法有get、set、has、delete

[Set、WeakSet、Map及WeakMap](https://github.com/sisterAn/blog/issues/24)

## 9、setTimeout、Promise、Async/Await 的区别

事件循环中分为**宏任务队列**和微任务队列。

- settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行；
- promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
- async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式，async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

## 10、typeof 和 instanceof 的区别

`typeof`表示是对某个变量类型的检测，基本数据类型除了`null`都能正常的显示为对应的类型，引用类型除了函数会显示为`'function'`，其它都显示为`object`。

而`instanceof`它主要是**用于检测某个构造函数的原型对象在不在某个对象的原型链上**。

## 11、typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

## 12、一句话描述一下this

对于函数而言指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局来说，`this`指向`window`。

## 13、函数内的this是在什么时候确定的？

函数调用时，指向最后调用的那个对象

## 14、什么是 async / await 及其如何工作，有什么优缺点？

async / await 是一种建立在 Promise 之上的编写异步或非阻塞代码的新方法，被普遍认为是 js 异步操作的最终且最优雅的解决方案。相对于 Promise 和回调，它的可读性和简洁度都更高。

`async` 是异步的意思，而 `await` 是 `async wait`的简写，即异步等待。

一个函数如果加上 async ，那么该函数就会返回一个 Promise。

**优缺点：**

- `async/await`的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。
- 当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

## 15、介绍下执行上下文

## 16、什么是作用域？作用域链？

当JavaScript在运行的时候，它需要一些空间让它来存储本地变量（local variables）。我们将这些空间称为作用域对象（Scope object），有时候也称作`LexicalEnvironment`。

每一个作用域都有对其父作用域的引用。当我们使用一个变量的时候，`Javascript引擎` 会通过变量名在当前作用域查找，若没有查找到，会一直沿着作用域链一直向上查找，直到 `global` 全局作用域。

> 当代码试图访问一个变量的时候，解释器将在当前的作用域对象中查找这个属性。如果这个属性不存在，那么解释器就会在父作用域对象中查找这个属性。就这样，一直向父作用域对象查找，直到找到该属性或者再也没有父作用域对象。我们将这个查找变量的过程中所经过的作用域对象称作作用域链（Scope chain）。

## 17、call apply bind 区别

- 语法
  - **call:`对象.call(要指的对象，"参数1"，"参数2")`**
  - **apply:`对象.apply(要指的对象，[参数1，参数2])`**
- 相同点
  - **他们三者都是改变this的指向**
  - **第一个参数都是this要指向的对象**
  - **都可以后续传参**
- 不同点
  - **call和apply都是对函数直接调用，bind方法返回的是一个函数需要()调用**
  - **call传递参数的时候是字符串对应传参，如：**`obj.say.call(xh, "高等中学", "九年级")`
  - **apply第二个参数是一个数组,如：**`obj.say.apply(xh, ["高等中学", "九年级"])`
  - **bind可以在调用处传参，如：**`obj.say.bind(xh)("高等中学", "七年级")`
  - **bind还可以向call一样传参,如：**`obj.say.bind(xh, "高等中学", "九年级")()`

## 18、let、const、var 的区别有哪些？

- var是ES5提出的，let和const是ES6提出的。

- **var声明的变量存在变量提升**（将变量提升到当前作用域的顶部）。即变量可以在声明之前调用，值为undefined。
  
  **let和const不存在变量提升**。即它们所声明的变量一定要在声明后使用，否则报ReferenceError错。

- **let和const存在暂时性死区**。即只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

- **var允许重复声明变量**。let和const在同一作用域不允许重复声明变量。

- **var不存在块级作用域**。let和const存在块级作用域。

- var和let可以**修改声明的变量**。
  const声明一个只读的常量。一旦声明，常量的值就不能改变。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。

## 19、有些页面需要嵌入第三方页面（iframe），如何进行通信

[https://www.cnblogs.com/wxlevel/p/7646943.html](https://www.cnblogs.com/wxlevel/p/7646943.html)

**同域**：

**方法调用**

> 父页面调用子页面方法： `FrameName.window.childMethod();`
> 子页面调用父页面方法： `parent.window.parentMethod();`

**DOM元素访问**

获取到页面的`window.document`对象后，即可访问DOM元素

> 注意事项:
> 要确保在`iframe`加载完成后再进行操作，如果`iframe`还未加载完成就开始调用里面的方法或变量，会产生错误。
> 判断`iframe`是否加载完成有两种方法：
> 
> 1. iframe上用onload事件
> 2. 用document.readyState=="complete"来判断

**跨域**：

如果`iframe`的链接是外部页面，因为安全机制就不能使用同域名下的通信方式了。

**父页面向子页面传递数据**

实现的技巧是利用`location`对象的`hash值`，通过它传递通信数据。
在父页面设置`iframe`的`src`后面多加个`data字符串`，然后在子页面中通过某种方式能即时的获取到这儿的data就可以了，例如：

> 1. 在子页面中通过setInterval方法设置定时器，监听`location.href`的变化即可获得上面的data信息
> 2. 然后子页面根据这个data信息进行相应的逻辑处理

**子页面向父页面传递数据**

实现技巧就是利用一个代理`iframe`，它嵌入到子页面中，并且和父页面必须保持是同域，
然后通过它充分利用上面第一种通信方式的实现原理就把子页面的数据传递给代理iframe，
然后由于代理的iframe和主页面是同域的，所以主页面就可以利用同域的方式获取到这些数据。
使用`window.top`或者`window.parent.parent`获取浏览器最顶层window对象的引用。