## 1、什么是闭包？

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中变量，那么函数 B 就是闭包。

> 闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
>
> 在 JS 中，闭包存在的意义就是让我们可以间接的访问函数内部的变量。
>
> 会导致垃圾回收机制没有把当前变量回收掉，这样的操作带来了**内存泄漏**的影响，当内存泄漏到一定程度会影响性能，甚至导致程序崩溃。因此在项目中我们要尽量避免内存泄漏。

作用：

1. 可以读取函数内部的变量

2. 让这些变量的值始终保存在内存中

## 2、什么是原型

构造函数，是一种特殊的方法，主要用来创建对象时初始化对象。

每个构造函数都有一个 prototype (原型)(箭头函数以及Function.prototype.bind() 没有)属性，这个 prototype (原型)是一个指针，指向一个对象，这个对象的用途是包含特定类型的所有实例共享的属性方法，即这个原型对象是用来给实例共享属性和方法的。

每个实例对象的 `__proto__ ` 都指向这个【构造函数/类】的 prototype 属性。 

## 3、什么是原型链？

如果我们得到一个实例化对象，当我们访问对象属性时，它会现在自身属性上查找，如果没有这个属性，就会去 `__proto__` 中查找，一层层向上查找直到顶层对象 Object，这个查找的过程就是原型链。

## 4、深拷贝浅拷贝

- **浅拷贝**：浅拷贝通过 ES6 新特性 Object.assign() 或者通过扩展运算法 ... 来达到浅拷贝的目的，浅拷贝修改副本，不会影响原数据，但缺点是浅拷贝只能拷贝第一层的数据，且都是值类型数据，如果有引用型数据，修改 副本会影响原数据。

- **深拷贝**：通过利用 JSON.parse(JSON.stringify()) 来实现深拷贝的目的，但利用 JSON 拷贝也是有缺点的， 当要拷贝的数据中含有 undefined/function/symbol 类型是无法进行拷贝的，当然我们想项目开发中需要 深拷贝的数据一般不会含有以上三种类型，如有需要可以自己在封装一个函数来实现。

## 5、JavaScript 规定了哪几种语言类型？

在 JavaScript 规范中，共定义了七种数据类型，分为 “基本类型” 和 “引用类型” 两大类，如下所示：

- **基本类型**：String、Number、Boolean、Symbol、Undefined、Null 
- **引用类型**：Object

## 6、什么是作用域链？

在 JavaScript 中，作用域分为：

**全局作用域**：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域

**函数作用域**：在固定的代码片段才能被访问

一般情况，**变量取值**在**创建这个变量的函数作用域**中取值，如果当前作用域中没有查到值，就会向上级作用域去查，知道查到全局作用域，这个查找过程形成的链条就叫做作用域链。

> 变量对象 Variable Object（VO）
>
> 活动对象 Activation Object（AO）
>
> 作用域链 Scope Chain

## 7、null 和 undefined 有什么区别？

1. null 是表示一个“无”的对象，转为数值为0，undefined 是表示一个“无”的原始值，转为数值为 NaN。当声明的变量还未初始化时，变量的默认值是 undefined

2. null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象

3. undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：

   - 变量被声明了，但没有赋值时，就等于 undefined
   - 调用函数时，应该提供的参数没有提供，该参数等于 undefined
   - 对象没有赋值属性，该属性的值为 undefined
   - 函数没有返回值时，默认返回 undefined

4. null 表示”没有对象”，即该处不应该有值。典型用法是：

   - 作为函数的参数，表示该函数的参数不是对象
   - 作为对象原型链的终点

5. ```js
   null == undefined // true
   ```

## 8、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

- Set
  - 成员唯一、无序且不重复
  - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
  - 可以遍历，方法有：add、delete、has
- WeakSet
  - 成员都是对象
  - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
  - 不能遍历，方法有add、delete、has
- Map
  - 本质上是键值对的集合，类似集合
  - 可以遍历，方法很多可以跟各种数据格式转换
- WeakMap
  - 只接受对象作为键名（null除外），不接受其他类型的值作为键名
  - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
  - 不能遍历，方法有get、set、has、delete

[Set、WeakSet、Map及WeakMap](https://github.com/sisterAn/blog/issues/24)

## 9、setTimeout、Promise、Async/Await 的区别

事件循环中分为**宏任务队列**和微任务队列。

- settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行；
- promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
- async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式，async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。

## 10、typeof 和 instanceof 的区别

`typeof`表示是对某个变量类型的检测，基本数据类型除了`null`都能正常的显示为对应的类型，引用类型除了函数会显示为`'function'`，其它都显示为`object`。

而`instanceof`它主要是**用于检测某个构造函数的原型对象在不在某个对象的原型链上**。

## 11、typeof 为什么对 null 错误的显示

这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

## 12、一句话描述一下this

对于函数而言指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局来说，`this`指向`window`。

## 13、函数内的this是在什么时候确定的？

函数调用时，指向最后调用的那个对象