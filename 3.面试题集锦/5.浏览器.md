## 1、常见的浏览器内核有哪些?

| **浏览器/RunTime** | **内核（渲染引擎）** | **JavaScript 引擎**                                          |
| :----------------- | :------------------- | :----------------------------------------------------------- |
| Chrome             | webkit->blink        | V8                                                           |
| FireFox            | Gecko                | SpiderMonkey                                                 |
| Safari             | Webkit               | JavaScriptCore                                               |
| Edge               | EdgeHTML             | Chakra(for JavaScript)                                       |
| IE                 | Trident              | JScript（IE3.0-IE8.0）                                       |
| Opera              | Presto->blink        | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |
| Node.js            | -                    | V8                                                           |

## 2、介绍一下对浏览器内核的理解

浏览器内核主要分为两部分：**渲染引擎**（Layout Engineer 或 Render Engine）和 **JS 引擎**
- 渲染引擎：负责取得网页的内容（HTML，XML 和图像等），整理讯息（例如 CSS），以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。
- JS 引擎：解析和执行 JavaScript 来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向与只指渲染引擎。

## 3、浏览器是多进程还是单进程

浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。

浏览器每个进程有多个线程，主要有以下线程

1. **GUI 渲染线程**

   负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。
   和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。

2. **JS 引擎线程**

   单线程工作，负责解析运行 JavaScript 脚本。
   和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。

3. **事件触发线程**

   当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。

4. **定时器触发线程**

   浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。
   开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。

5. **http 请求线程**

   http 请求的时候会开启一条请求线程。
   请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。

## 4、为什么 JavaScript 是单线程的，与异步冲突吗

> JS 中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。JS 的设计初衷就没有考虑这些，针对 JS 这种不具备并行任务处理的特性，我们称之为“单线程”。

JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行。

举个通俗例子，假设 JS 支持多线程操作的话，JS 可以操作 DOM，那么一个线程在删除 DOM，另外一个线程就在获取 DOM 数据，这样子明显不合理，这算是证明之一。

**异步机制**是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS 执行线程和事件触发线程共同完成的。

- JS 执行线程发起异步请求（浏览器会开启一个 HTTP 请求线程来执行请求，这时 JS 的任务完成，继续执行线程队列中剩下任务）
- 然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待 JS 处理

再比如定时器触发(settimeout 和 setinterval) 是由**「浏览器的定时器线程」**执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到 JS 执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。

所以这么说，JS 单线程与异步更多是浏览器行为，之间不冲突。

## 5、CSS加载会造成阻塞吗

- CSS 不会阻塞 DOM 解析，但会阻塞 DOM 渲染。
- CSS 会阻塞 JS 执行，并不会阻塞 JS 文件下载

先讲一讲CSSOM作用

- 第一个是提供给 JavaScript 操作样式表的能力
- 第二个是为布局树的合成提供基础的样式信息
- 这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

由浏览器渲染流程我们可以看出：

DOM 和 CSSOM 通常是并行构建的，所以**「CSS 加载不会阻塞 DOM 的解析」**。

然而由于 Render Tree 是依赖 DOM Tree 和 CSSOM Tree 的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染，因此，**「CSS 加载会阻塞 DOM 渲染」**。

由于 JavaScript 是可操纵 DOM 和 CSS 样式 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果,浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。

有个需要注意的点就是：

**「有时候 JS 需要等到 CSS 的下载，这是为什么呢？」**

仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等 CSS 控制的属性，浏览器是需要计算的，也就是依赖于 CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行 JS。

JS 文件下载和 CSS 文件下载是并行的，有时候 CSS 文件很大，所以 JS 需要等待。

因此,样式表会在后面的 js 执行前先加载执行完毕,所以**「css 会阻塞后面 js 的执行」**。

## 6、为什么 JS 会阻塞页面加载

**JS 阻塞 DOM 解析**，也就会阻塞页面

> 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
>
> 因此为了防止渲染出现不可预期的结果，浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。
>
> 当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
>
> 当浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。
>
> 因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
>
> 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。

## 7、defer 和 async 的区别 ?

- 两者都是异步去加载外部 JS 文件，不会阻塞 DOM 解析
- Async 是在外部 JS 加载完成后，浏览器空闲时，Load 事件触发前执行，标记为 async 的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有**「src」**属性的脚本）。
- defer 是在 JS 加载完成后，整个文档解析完成后，触发 `DOMContentLoaded` 事件前执行，如果缺少 `src` 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用