## 1、常见的浏览器内核有哪些?

| **浏览器/RunTime** | **内核（渲染引擎）** | **JavaScript 引擎**                                          |
| :----------------- | :------------------- | :----------------------------------------------------------- |
| Chrome             | webkit->blink        | V8                                                           |
| FireFox            | Gecko                | SpiderMonkey                                                 |
| Safari             | Webkit               | JavaScriptCore                                               |
| Edge               | EdgeHTML             | Chakra(for JavaScript)                                       |
| IE                 | Trident              | JScript（IE3.0-IE8.0）                                       |
| Opera              | Presto->blink        | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |
| Node.js            | -                    | V8                                                           |

## 2、介绍一下对浏览器内核的理解

浏览器内核主要分为两部分：**渲染引擎**（Layout Engineer 或 Render Engine）和 **JS 引擎**
- 渲染引擎：负责取得网页的内容（HTML，XML 和图像等），整理讯息（例如 CSS），以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。
- JS 引擎：解析和执行 JavaScript 来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向与只指渲染引擎。

## 3、浏览器是多进程还是单进程

浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。

浏览器每个进程有多个线程，主要有以下线程

1. **GUI 渲染线程**

   负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。
   和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。

2. **JS 引擎线程**

   单线程工作，负责解析运行 JavaScript 脚本。
   和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。

3. **事件触发线程**

   当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。

4. **定时器触发线程**

   浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。
   开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。

5. **http 请求线程**

   http 请求的时候会开启一条请求线程。
   请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。

## 4、为什么 JavaScript 是单线程的，与异步冲突吗

> JS 中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。JS 的设计初衷就没有考虑这些，针对 JS 这种不具备并行任务处理的特性，我们称之为“单线程”。

JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行。

举个通俗例子，假设 JS 支持多线程操作的话，JS 可以操作 DOM，那么一个线程在删除 DOM，另外一个线程就在获取 DOM 数据，这样子明显不合理，这算是证明之一。

**异步机制**是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS 执行线程和事件触发线程共同完成的。

- JS 执行线程发起异步请求（浏览器会开启一个 HTTP 请求线程来执行请求，这时 JS 的任务完成，继续执行线程队列中剩下任务）
- 然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待 JS 处理

再比如定时器触发(settimeout 和 setinterval) 是由**「浏览器的定时器线程」**执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到 JS 执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。

所以这么说，JS 单线程与异步更多是浏览器行为，之间不冲突。

## 5、CSS加载会造成阻塞吗

- CSS 不会阻塞 DOM 解析，但会阻塞 DOM 渲染。
- CSS 会阻塞 JS 执行，并不会阻塞 JS 文件下载

先讲一讲CSSOM作用

- 第一个是提供给 JavaScript 操作样式表的能力
- 第二个是为布局树的合成提供基础的样式信息
- 这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

由浏览器渲染流程我们可以看出：

DOM 和 CSSOM 通常是并行构建的，所以**「CSS 加载不会阻塞 DOM 的解析」**。

然而由于 Render Tree 是依赖 DOM Tree 和 CSSOM Tree 的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染，因此，**「CSS 加载会阻塞 DOM 渲染」**。

由于 JavaScript 是可操纵 DOM 和 CSS 样式 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。

因此为了防止渲染出现不可预期的结果,浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。

有个需要注意的点就是：

**「有时候 JS 需要等到 CSS 的下载，这是为什么呢？」**

仔细思考一下，其实这样做是有道理的，如果脚本的内容是获取元素的样式，宽高等 CSS 控制的属性，浏览器是需要计算的，也就是依赖于 CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行 JS。

JS 文件下载和 CSS 文件下载是并行的，有时候 CSS 文件很大，所以 JS 需要等待。

因此,样式表会在后面的 js 执行前先加载执行完毕,所以**「css 会阻塞后面 js 的执行」**。

## 6、为什么 JS 会阻塞页面加载

**JS 阻塞 DOM 解析**，也就会阻塞页面

> 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
>
> 因此为了防止渲染出现不可预期的结果，浏览器设置 **「GUI 渲染线程与 JavaScript 引擎为互斥」**的关系。
>
> 当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。
>
> 当浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。
>
> 因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
>
> 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。

## 7、defer 和 async 的区别 ?

- 两者都是异步去加载外部 JS 文件，不会阻塞 DOM 解析
- Async 是在外部 JS 加载完成后，浏览器空闲时，Load 事件触发前执行，标记为 async 的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有**「src」**属性的脚本）。
- defer 是在 JS 加载完成后，整个文档解析完成后，触发 `DOMContentLoaded` 事件前执行，如果缺少 `src` 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用

<img src="https://cloud-images-1255423800.cos.ap-guangzhou.myqcloud.com/Browser_async-defer.png" alt="async-defer" style="zoom: 80%;" />

1. `<script src="script.js"></script>` 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
2. `<script async src="script.js"></script>` 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
3. `<script defer src="myscript.js"></script>` 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

|       | 顺序                                                         | DOMContentLoaded                                             |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| async | **加载优先顺序**。脚本在文档中的顺序不重要 —— 先加载完成先执行 | 不相关。可能在文档加载完成前加载并执行完毕，如果脚本很小或者来自于缓存，同事文档如够长，就会发生这种情况 |
| defer | **文档顺序**（它们在文档中的顺序）                           | 在文档加载和解析完成之后（如果需要，则会等待），即在 DOMContentLoaded 之前执行 |

## 8、DOMContentLoaded 和 load 的区别？

- DOMContentLoaded 事件触发时：仅当 DOM 解析完成后，不包括样式表，图片等资源。
- onload 事件触发时：页面上所有的 DOM，样式表，脚本，图片等资源已经加载完毕。

那么也就是先 DOMContentLoaded -> load，那么在 Jquery 中，使用

`(document).read(callback)` 监听的就是 DOMContentLoaded 事件

`(document).load(callback)` 监听的就是 load 事件

### 再看 async 与 defer 的区别

1. 带 async 的脚本一定会在 load 事件之前执行，可能会在 DOMContentLoaded 之前或之后执行。

   - 情况1： HTML 还没有被解析完的时候，async 脚本已经加载完了，那么 HTML 停止解析，去执行脚本，脚本执行完毕后触发 DOMContentLoaded 事件

   - 情况2： HTML 解析完了之后，async 脚本才加载完，然后再执行脚本，那么在 HTML 解析完毕、async 脚本还没加载完的时候就触发 DOMContentLoaded 事件

2. 如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。

   - 情况1：HTML 还没解析完成时，defer 脚本已经加载完毕，那么 defer 脚本将等待 HTML 解析完成后再执行。defer 脚本执行完毕后触发 DOMContentLoaded 事件
   - 情况2：HTML 解析完成时，defer 脚本还没加载完毕，那么 defer 脚本继续加载，加载完成后直接执行，执行完毕后触发 DOMContentLoaded 事件

## 9、谈一谈你对 requestAnimationFrame（rAF）理解

### **高性能动画是什么，那它衡量的标准是什么呢？**

动画帧率可以作为衡量标准，一般来说画面在 60fps 的帧率下效果比较好。

换算一下就是，每一帧要在 16.7ms (16.7 = 1000/60) 内完成渲染。

我们来看看MDN对它的解释吧👇

> window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。*-- MDN*

当我们调用这个函数的时候，我们告诉它需要做两件事：

1. 我们需要新的一帧；
2. 当你渲染新的一帧时需要执行我传给你的回调函数

### rAF 与 setTimeout 相比

rAF(requestAnimationFrame) 最大的优势是**「由系统来决定回调函数的执行时机」**。

具体一点讲就是，系统每次绘制之前会主动调用 rAF 中的回调函数，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。

> 换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次(上一个知识点刚刚梳理完**「函数节流」**)，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

另外它可以自动调节频率。如果callback工作太多无法在一帧内完成会自动降低为30fps。虽然降低了，但总比掉帧好。

与 setTimeout 动画对比的话，有以下几点优势

- 当页面隐藏或者最小化时，setTimeout 仍然在后台执行动画，此时页面不可见或者是不可用状态，动画刷新没有意义，而言浪费CPU。
- rAF不一样，当页面处理未激活的状态时，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的rAF也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。