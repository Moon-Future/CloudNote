## 1、`.` VS `=` 操作符优先级

```js
let a = {n: 1};
let b = a;
a.x = a = {n: 2};

console.log(a.x)
console.log(b.x)
```

输出：

```js
undefined
{n: 2}
```

`.` 的操作优先级高于 `=`，`a.x = a = {n: 2}` => `a.x = (a = {n: 2})`，a.x 先执行，此事 a 与 b 的引用地址相同，然后执行括号总的表达式，改变 a 的指向。最终 `a = {n: 2}，b = {n: 1, x: {n: 2}}`

## 2、作用域、闭包

```js
var a = 0,  
	b = 0;
function A(a) {
    A = function (b) {
    	console.log(a + b++)
    }
	console.log(a++)
}
A(1)
A(2)
console.log(a)
```

输出：

```js
1
4
0
```

第一次执行函数 A 时，打印 1，a++ 后 a = 2，此时 A 重新赋值，函数中的变量 a 向上级作用域查找，找到 a = 2（已形成闭包，非全局变量 a）

## 3、类数组的 length

```js
var obj = {
    "2" : 3,
    "3" : 4,
    "length" : 2,
    "splice" : Array.prototype.splice,
    "push" : Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj)
```

输出：

```js
Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]

{
    2: 1
    3: 2
    length: 4
    push: ƒ push()
    splice: ƒ splice()
    __proto__: Object
}
```

第一次使用 push，obj 对象的 push 方法设置 obj[2] = 1，obj.length++；

第二次使用 push，obj 对象的 push 方法设置 obj[3] = 2，obj.length++；

使用 console.log() 方法输出的时候，因为 obj 上有 length 属性和 splice 方法，故将其作为数组输出打印，打印时因为数组未设置下标为 0 和  1的值，故打印的结果就是 empty，主动获取 obj[0] = undefined

